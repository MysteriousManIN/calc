"use strict";String.prototype.expression=function(){let index,expression,operator,result;expression=this;result=[];operator=["!","^","*","/","+","-"];const isInt=(num)=>{if(!isNaN(num)){num=num.toString().split(".");if(num[1]!==undefined&&num[1]!==""){return!1}else{return!0}}else{throw("isInt(): "+num+" is NaN")}};const numComes=(expression,index)=>{let str="";while(!isNaN(expression[index])){str+=expression[index];index++}if(expression[index]==="."){let{str:str1,idx:idx1}=intComes(expression,index+1);str+="."+str1;index=idx1+1}if(str.at(-1)==="."){str=str.split(".");if(parseInt(str[0])===0){str[0]="0"}str=str.join(".")}else{if(isInt(str)){if(parseInt(str)===0){str="0"}}else{str=str.split(".");str=parseInt(str[0])+"."+str[1]}}return{str:str,idx:index-1}};const intComes=(expression,index)=>{let str="";while(!isNaN(expression[index])){str+=expression[index];index++}if(expression[index]==="."){index++;while(!isNaN(expression[index])){index++}}return{str:str,idx:index-1}};for(index=0;index<expression.length;index++){let ele=expression[index];if(!isNaN(ele)){let{str,idx}=numComes(expression,index);if(!isNaN(str)){if(result.at(-1)==="-"){if(isNaN(result.at(-2))){str=result.pop()+str}}else if(result.at(-1)==="."){if(isInt(str)){if(str.at(-1)==="."){str=str.split(".");str=str[0]}}else{str=str.split(".");str=str[0]}if(isNaN(result.at(-3))&&result.at(-2)==="-"){result.pop();result.pop();str="-."+str}else{result.pop();str="."+str}}result.push(str)}index=idx}else if(ele==="."){if(result.length===0){result.push(".")}else if(result.at(-1)==="."){result.pop();result.push(".")}else{result.push(".")}}else if(ele==="-"){if(result.length===0){result.push("-")}else if(result.at(-1)==="-"){result.pop();result.push("-")}else if(result.at(-1)!=="."){result.push("-")}}else if(ele==="!"){if(!isNaN(result.at(-1))&&isInt(result.at(-1))){ele=parseInt(result.pop()).toString();result.push(ele,"!")}}else if(operator.includes(ele)){if(operator.slice(1,6).includes(result.at(-1))){result.pop();if(operator.slice(1,6).includes(result.at(-1))){result.pop()}}if(result.length!==0&&result.at(-1)!=="."){result.push(ele)}}}return result};Math.fact=(num)=>{num=parseInt(num);if(num===0){return 1}else{return num*Math.fact(num-1)}};Math.calc=(expression,afterDot=8)=>{const createStack=(expAry)=>{let i,stack=[];stack=expAry;expAry=[];for(i=0;i<stack.length;i++){if(stack[i]==="!"){let num=expAry.pop();if(num>=0){num=Math.fact(num);expAry.push(num.toString())}else{num=Math.fact(num*-1);expAry.push(num.toString()*-1)}expAry.push("*")}else{expAry.push(stack[i])}}expAry=expAry.join("").expression();stack=[];for(i=0;i<expAry.length;i++){if(!isNaN(expAry[i])){stack[i]=parseFloat(expAry[i])}else{stack[i]=expAry[i]}}i=0;while(isNaN(stack[i])&&stack[i]!==undefined){stack.shift();i++}i=stack.length-1;while(isNaN(stack[i])&&stack[i]!==undefined){stack.pop();i--}return stack};const checkStack=(stack)=>{let flag=0;for(let i=0;i<stack.length;i++){if(!isNaN(stack[i])&&i%2===0){}else if(isNaN(stack[i])&&i%2===1){}else{flag=1;break}}if(flag==1){return!1}else{return!0}};const infixToPostfix=(infix)=>{let index,postfix=[],waiting=[];let operator=[["^"],["*","/"],["+","-"]];for(index=0;index<infix.length;index++){let ele=infix[index];if(!isNaN(ele)){postfix.push(ele)}else{if(waiting.at(-1)!==undefined){let i=waiting.length-1;while(i>=0){let j=0;while(j<operator.length){if(operator[j].includes(ele)&&operator[j].includes(waiting.at(i))){postfix.push(waiting.pop());break}j++}if(waiting.at(i)!==undefined){if(operator.flat().indexOf(ele)>=operator.flat().indexOf(waiting.at(i))){postfix.push(waiting.pop())}}i--}}waiting.push(ele)}}while(waiting.length!==0){postfix.push(waiting.pop())}return postfix};const calculate=(postfix)=>{while(postfix.length!==1){let i,a,b,o,r;i=0;while(!isNaN(postfix[i])){i++}o=postfix[i];b=postfix[i-1];a=postfix[i-2];switch(o){case "+":r=a+b;break;case "-":r=a-b;break;case "*":r=a*b;break;case "/":r=a/b;break;case "^":r=Math.pow(a,b);break}delete postfix[i];delete postfix[i-1];delete postfix[i-2];postfix[i]=r;postfix=postfix.filter(v=>{if(v!==undefined)return!0})}let result=postfix[0];result=parseFloat(result);return result};let expAry,stack,result="";expAry=expression.expression();stack=createStack(expAry);if(checkStack(stack)){if(stack.length!==0){result=infixToPostfix(stack);result=parseFloat(calculate(result).toFixed(afterDot));if(isNaN(result)){result="Not a number"}}}else{result="Expression error"}return{expression:expAry.join(""),result:result}}